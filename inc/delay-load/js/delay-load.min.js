"use strict"; (() => { var pos = document.body.getBoundingClientRect().top, isFirstVisit = !0; window.localStorage.getItem("debloat_user") ? isFirstVisit = !1 : (window.localStorage.setItem("debloat_user", "debloat_user"), isFirstVisit = !0); const config = window.debloatConfig || {}, enableDebug = !0; let eventQueue = []; const origEventListeners = { HTMLDocument: document.addEventListener.bind(document), Window: window.addEventListener.bind(window) }; const eventCache = {}; let origReadyState; let setupDone = !1; let eventsTriggered = !1; let readyStateIntercepted = !1; let eventsDispatched = !1; let preloadDone = !1; let jsScripts = []; let cssLinks = []; function processScriptsSequentially() { const scripts = [...document.querySelectorAll("script[data-debloat-delay]")]; const links = [...document.querySelectorAll("link[data-debloat-delay]")]; const jqueryScripts = scripts.filter(script => script.src && script.src.includes("jquery") || script.dataset.src && script.dataset.src.includes("jquery")); const otherScripts = scripts.filter(script => !jqueryScripts.includes(script)); const processJquery = async () => { for (const script of jqueryScripts) { await loadScript(script); await new Promise(resolve => setTimeout(resolve, 50)) } let jQueryCheckAttempts = 0; const checkJQuery = async () => { if (typeof window.jQuery !== "undefined") { for (const script of otherScripts) { await loadScript(script) } } else if (jQueryCheckAttempts < 10) { jQueryCheckAttempts++; setTimeout(checkJQuery, 100) } else { console.warn("jQuery not found after waiting, proceeding with other scripts"); for (const script of otherScripts) { await loadScript(script) } } }; checkJQuery() }; processJquery().then(() => { links.forEach(link => loadScript(link)) }) } function init() { if (isFirstVisit) initScripts(), initStyles(); else { processScriptsSequentially() } document.addEventListener("debloat-load-css", () => initStyles(!0)); document.addEventListener("debloat-load-js", () => initScripts(!0)) } function initScripts(immediate) { jsScripts = [...document.querySelectorAll("script[data-debloat-delay]")]; if (jsScripts.length) { setupEventTracking(); initDelayedAssets("js", immediate) } } function initStyles(immediate) { cssLinks = [...document.querySelectorAll("link[data-debloat-delay]")]; if (cssLinks.length) { initDelayedAssets("css", immediate) } } function initDelayedAssets(type, immediate) { type = type || "js"; const loadMethod = immediate ? "onload" : config[type + "DelayType"] || "onload"; const loadFunc = type === "js" ? loadScriptsSequential : loadStylesAll; if (type === "js") { immediate || loadMethod === "onload" ? preloadAssets() : waitForReady(preloadAssets) } switch (loadMethod) { case "onload": waitForReady(() => loadFunc(immediate)); break; case "interact": let interactionDetected = !1; const eventTypes = ["mousemove", "mousedown", "keydown", "touchstart", "wheel"]; const handleInteraction = () => { if (interactionDetected) { return } interactionDetected = !0; type === "js" ? waitForDomReady(() => setTimeout(loadFunc, 2)) : loadFunc() }; eventTypes.forEach(eventType => { document.addEventListener(eventType, handleInteraction, { passive: !0, once: !0 }) }); if (type === "js" && config.jsDelayMax) { waitForDomReady(() => setTimeout(handleInteraction, config.jsDelayMax * 1e3)) } break; case "custom-delay": waitForReady(() => { const delay = parseInt(element.dataset.customDelay) * 1e3; setTimeout(loadFunc, delay) }); break } } function loadStylesAll() { cssLinks.forEach(link => loadScript(link)) } function loadScriptsSequential(immediate) { preloadAssets(); if (!immediate) { readyStateIntercepted = !0; origReadyState = document.readyState; let currentState = "loading"; Object.defineProperty(document, "readyState", { configurable: !0, get() { return currentState }, set(state) { return currentState = state } }) } let resolvePromise; const loadComplete = new Promise(resolve => resolvePromise = resolve); const loadNext = () => { if (!jsScripts.length) { resolvePromise(); return } const promise = loadScript(jsScripts.shift()); promise.then(loadNext) }; loadNext(); loadComplete.then(fireEvents).catch(err => { console.error(err); fireEvents() }); setTimeout(() => !eventQueue.length || fireEvents(), 45e3) } function preloadAssets(relType) { if (preloadDone) { return } preloadDone = !0; jsScripts.forEach(script => { const src = script.src || script.dataset.src; if (!src) { return } const link = document.createElement("link"); Object.assign(link, { rel: relType || "preload", as: "script", href: src, ...script.crossOrigin && { crossOrigin: script.crossOrigin } }); document.head.append(link) }) } function loadScript(element) { let promise; const src = element.dataset.src; const createPromise = el => { return new Promise(resolve => { el.addEventListener("load", resolve); el.addEventListener("error", resolve) }) }; if (src) { const script = document.createElement("script"); promise = createPromise(script); element.getAttributeNames().forEach(attr => { attr === "src" || (script[attr] = element[attr]) }); script.async = !1; script.src = src; element.parentNode.replaceChild(script, element) } else if (element.type && element.type === "text/debloat-script") { element.type = element.dataset.type || "text/javascript"; element.text += " " } const href = element.dataset.href; if (href) { promise = createPromise(element); element.href = href } ["debloatDelay", "src"].forEach(attr => { element.dataset[attr] = ""; delete element.dataset[attr] }); return promise || Promise.resolve() } function setupEventTracking() { if (setupDone) { return } setupDone = !0; const trackEvent = (type, context) => { context.addEventListener(type, event => eventCache[type] = event) }; trackEvent("DOMContentLoaded", document); trackEvent("load", window); trackEvent("readystatechange", document); trackEvent("pageshow", window); const eventHandlerProxy = function (type, handler, ...args) { const trackedEvents = ["readystatechange", "DOMContentLoaded", "load", "pageshow"]; if (readyStateIntercepted && !eventsTriggered && trackedEvents.includes(type)) { enableDebug && console.log("Adding: ", type, handler, args); const eventData = { event: type, cb: handler, context: this, args: args }; eventQueue.push(eventData); return } if (origEventListeners[this.constructor.name]) { origEventListeners[this.constructor.name].call(this, type, handler, ...args) } }; document.addEventListener = eventHandlerProxy.bind(document); window.addEventListener = eventHandlerProxy.bind(window); Object.defineProperty(window, "onload", { set(handler) { window.addEventListener("load", handler) } }) } function dispatchEvent(eventData) { try { eventData.cb.call(eventData.context, eventCache[eventData.event], ...eventData.args) } catch (err) { console.error(err) } } function fireEvents() { if (eventsDispatched) { return } enableDebug && console.log("Firing Load Events", eventQueue); eventsDispatched = !0; const readystateEvents = eventQueue.filter(e => e.event === "readystatechange"); document.readyState = "interactive"; readystateEvents.forEach(e => dispatchEvent(e)); for (const event of eventQueue) { event.event === "DOMContentLoaded" && dispatchEvent(event) } for (const event of eventQueue) { event.event === "load" && dispatchEvent(event) } eventQueue = []; eventsDispatched = !1; eventsTriggered = !0; readyStateIntercepted = !1; waitForReady(() => { document.readyState = "complete"; setTimeout(() => { readystateEvents.forEach(e => dispatchEvent(e)) }, 2) }) } function waitForReady(callback) { const state = origReadyState || document.readyState; state === "complete" ? callback() : origEventListeners.Window("load", () => callback()) } function waitForDomReady(callback) { document.readyState !== "loading" ? callback() : origEventListeners.Window("DOMContentLoaded", () => callback()) } init() })();